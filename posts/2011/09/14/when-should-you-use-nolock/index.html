<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" type="image/png" href="http://localhost:1313/favicon.ico" />
<meta property="og:url" content="http://localhost:1313/posts/2011/09/14/when-should-you-use-nolock/">
  <meta property="og:site_name" content="tenbulls blog">
  <meta property="og:title" content="When should you use NOLOCK?">
  <meta property="og:description" content="Well the quick answer to that question is never. And there you have it, the quickest blog post in history (perhaps!).
…Except that I should really have said “When should you use READUNCOMMITTED isolation or hint?” and then the question takes a little more of a surprising turn. Let me first start and explain why I have categorically ruled against the use of NOLOCK. The reason, is that at some point in the dim and distant future Microsoft may decide to remove this hint from the product. If they could do it today, they probably would; the only thing that is really stopping them is the numerous lines of external T-SQL code that dirtys the floors of many Development teams around the world.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2011-09-14T12:31:00+01:00">
    <meta property="article:modified_time" content="2011-09-14T12:31:00+01:00">
    <meta property="article:tag" content="SQL">
    <meta property="article:tag" content="Concurrency">

<title>tenbulls blog | When should you use NOLOCK?</title>

    <link rel="stylesheet" href="/css/main.css">
      <link rel="stylesheet" href="/css/palette/default.css">

      <script src="/js/main.js"></script>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

</head>

<body
    class="dark"
>
  
  <main>
    
  <div class="container pt-5">
    <div class="row mt-5 pt-5">
      
  <nav aria-label="breadcrumb" class="small navbar navbar-expand-lg">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#collapsibleMenu" aria-controls="collapsibleMenu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse mt-3 mt-md-0" id="collapsibleMenu">
      <ol class="breadcrumb fw-bold">
    <li class="breadcrumb-item my-1 my-md-0 ms-3 ms-md-0">
      <a href="/about"
        
      >about</a>
      
    </li>
    <li class="breadcrumb-item my-1 my-md-0 ms-3 ms-md-0">
      <a href="/"
        
      >home</a>
      
    </li>
    <li class="breadcrumb-item my-1 my-md-0 ms-3 ms-md-0">
      <a href="https://www.meetup.com/hybrid-virtual-group/"
        
          target="_blank" rel="noopener noreferrer"
        
      >meetup</a>
      
    </li>
    <li class="breadcrumb-item my-1 my-md-0 ms-3 ms-md-0">
      <a href="/posts"
        class="text-decoration-underline link-offset-3"
        
      >posts</a>
      
    </li>
    <li class="breadcrumb-item my-1 my-md-0 ms-3 ms-md-0">
      <a href="/tags"
        
      >tags</a>
      
    </li>
      </ol>
    </div>
  </nav>

    </div>
    <div class="post">
      <header class="mb-4">
        <h1 class="text-uppercase">When should you use NOLOCK?</h1>
        
        
        <div aria-label="breadcrumb">
          <ol class="breadcrumb">
            <li class="breadcrumb-item small">
              
              <time datetime="2011-09-14T12:31:00&#43;01:00">September 14, 2011</time>
            </li>
            
            
            <li class="breadcrumb-item small">
              5 minutes
            </li>
          </ol>
        </div>
      </header>
      
      <article>
        <p>Well the quick answer to that question is never. And there you have it, the quickest blog post in history (perhaps!).</p>
<p>…Except that I should really have said “When should you use READUNCOMMITTED isolation or hint?” and then the question takes a little more of a surprising turn. Let me first start and explain why I have categorically ruled against the use of NOLOCK. The reason, is that at some point in the dim and distant future Microsoft may decide to remove this hint from the product. If they could do it today, they probably would; the only thing that is really stopping them is the numerous lines of external T-SQL code that dirtys the floors of many Development teams around the world.</p>
<p>Of course technically READUNCOMMITTED and NOLOCK are identical with the exception that the former can also be used to set the session level ISOLATION LEVEL as well as the statement level.</p>
<p>Now, moving swiftly onto a surprising find by myself whilst I was putting together material and investigating ideas for my “READPAST &amp; Furious” presentation, which is based loosely on the excellent presentations that Kalen Delaney has given over the last 6 years or more on the subject of Locking, Blocking and Concurrency. It is a homage of sorts. During her SQL PASS Summit 2010 Pre-Conference day “Locking and Blocking and Row Versions, Oh My!“, there was a question posed about whether there was ever a good reason to use the NOLOCK hint. The outcome was (quite unsurprising) ‘not really, maybe only for troubleshooting’.</p>
<p>Another thing that is commonly said about NOLOCK is that it does not take out Shared locks and this is the reason why when using the NOLOCK (or READUNCOMMITTED) hint, we are able to read uncommitted data. Since a Shared lock is not taken or requested, there is no incompatibility detected by the lock manager and therefore no waiting for Exclusive locks to be released from any dirty pages.</p>
<p>Now imagine my surprise when I was playing with several SELECT statements and came across locks being acquired when using READUNCOMMITTED (or NOLOCK dont forget!) hint. So if I perform a simple “SELECT * FROM orders WITH (READUNCOMMITTED) from an entire table we can see what locks (if any) are acquired…</p>
<p>Ooooh look Ma, Locks!!!</p>
<p>Now perhaps less of a surprise is the acquiring of a Sch-S lock (otherwise known as a Schema Stability lock) on the table itself. This is (obviously) being acquired in order to prevent any Sch-M locks being taken whilst the SELECT executes so that the table structure cannot be changed, and this happens with every query. In fact if you look at Books Online it evens warns you that this is what will happen :-</p>
<p>“READUNCOMMITTED and NOLOCK hints apply only to data locks. All queries, including those with READUNCOMMITTED and NOLOCK hints, acquire Sch-S (schema stability) locks during compilation and execution. Because of this, queries are blocked when a concurrent transaction holds a Sch-M (schema modification) lock on the table. For example, a data definition language (DDL) operation acquires a Sch-M lock before it modifies the schema information of the table. Any concurrent queries, including those running with READUNCOMMITTED or NOLOCK hints, are blocked when attempting to acquire a Sch-S lock. Conversely, a query holding a Sch-S lock blocks a concurrent transaction that attempts to acquire a Sch-M lock. For more information about lock behavior, see Lock Compatibility (Database Engine).“</p>
<p>Much more surprising is the acquiring of the Shared lock which is classed as a “[BULK_OPERATION]” in the TextData column. Now this one was totally unexpected and if we take a look at the Type column we see the value “12=HOBT” (Heap or B-Tree). This table my friends is in fact a Heap, which is only of slight relevance to this investigation but is worth remembering. So to summarize so far, using READUNCOMMITTED hint in our SELECT against a Heap causes a Schema Stability lock on table object AND a special [Bulk Operation] Shared lock on the Heap!</p>
<p>Next thing I am now going to do is run the SELECT statement under READ COMMITTED isolation. Doing so we get the following results and they are just as we expected, a single Intent Shared lock on the table object and multiple Shared locks acquired and released on each and every Page.</p>
<p>Normality</p>
<p>Now then, let us forget for a moment the “Uncommitted” argument when using READUNCOMMITTED isolation and just agree on one thing -locking was more efficient in the first example wasn’t it?! From a resource perspective, having to acquire and release all those page locks on a very large table would take it’s toll in a very high through put system.</p>
<p>Now the next thing I am going to do is run the SELECT * FROM orders statement in SERIALIZABLE isolation, and again no real surprises with what happens. You see that an Intent Shared lock and a Shared lock is acquired (and subsequently released) on the table.</p>
<p>Readings are normal Jim.</p>
<p>What I am going to do now is to create a clustered index on the table and repeat the SELECT using READUNCOMMITTED and the result (from a locking perspective) is even better as you can see below.</p>
<p>We only have stability</p>
<p>So this time the READUNCOMMITTED lock gives us an even more efficient turn around once the clustered index is in place, it simply takes out a single Schema Stability lock on the table. We go back then to the original question, “When should you use NOLOCK READUNCOMMITTED?” and I shall tell you! Whenever you are querying tables that are housed in read only databases, read only filegroups, read only file systems, Scalable Shared Databases (in short committed data that is read only) it makes perfect sense to use a locking strategy that uses no locking due to the following reasons:-</p>
<p>Improves concurrency
Reduces lock manager overhead
Reduces memory usage of locks
And what of the dirty data you might ask? If it is read only there is no danger of it being changed and therefore no danger of lost updates or dirty reads. In other words (think of “The Matrix” here) …. “Do not try and bend the spoon isolation. That’s impossible. Instead… only try to realize the truth. There is no spoon isolation (required)“.</p>

      </article>
      
  <div class="tags pb-4 pt-2">
    
    
        <a class="badge rounded-pill text-uppercase text-bg-secondary" href="/tags/sql/">SQL</a>
        <a class="badge rounded-pill text-uppercase text-bg-secondary" href="/tags/concurrency/">Concurrency</a>
  </div>

      <div class="row">
    <div class="col-md">
        
        <a href="http://localhost:1313/posts/2011/08/30/how-to-increase-your-virtual-processors-in-the-os/">
            <span>previous: </span>
            <span>How to increase your OS Virtual Processors</span>
        </a>
        
    </div>
    <div class="col-md text-md-end">
        
        <a href="http://localhost:1313/posts/2012/01/25/sqlrally-and-beyond/">
            <span>next: </span>
            <span>SQLRally and Beyond</span>
        </a>
        
    </div>
</div>
      
    </div>
  </div>
  <footer>
    <div class="container mt-4 pb-1">
    <p class="small opacity-75">
        Copyright © 2026 Mark Broadbent
        
    </p>
</div>

  </footer>

  </main>

  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>
